// ServerInterface represents all server handlers.
type ServerInterface interface {
{{range .}}{{.SummaryAsComment }}
// ({{.Method}} {{.Path}})
{{.OperationId}}(ctx *{{.OperationId}}Context{{genParamArgs .PathParams}}{{if .RequiresParamObject}}, params {{.OperationId}}Params{{end}}) error
{{end}}
}

{{ range . }}
{{ $op := . }}
// {{.OperationId}}Context is a context customized for {{.OperationId}} ({{.Method}} {{.Path}}).
type {{.OperationId}}Context struct {
    echo.Context
}
{{- if .HasBody }}

// The body parsers
{{- range .Bodies }}
// Parse{{.NameTag}}Body tries to parse the body into the respective structure and validate it.
func (c *{{$op.OperationId}}Context) Parse{{.NameTag}}Body() ({{$op.OperationId}}{{.NameTag}}Body, error) {
    var resp {{$op.OperationId}}{{.NameTag}}Body
	return resp, bindValidateBody(c, &resp)
}
{{- end }}
{{- end }}

{{- if gt (len .GetResponseTypeDefinitions) 0 }}

// Responses
{{ if $op.HasEmptySuccess }}
// OK returns the successful response with no body.
func (c *{{$op.OperationId}}Context) OK() error {
    return c.NoContent(200)
}
{{- end }}
{{- range .GetResponseIndependentTypeDefinitions }}
{{ $respType := .TypeName }}
{{- if or (eq .ResponseName "1XX") (eq .ResponseName "2XX") (eq .ResponseName "3XX") (eq .ResponseName "4XX") (eq .ResponseName "5XX") }}
// Respond{{.ResponseName}} responses with the given code in range and the JSON response.
func (c *{{$op.OperationId}}Context) Respond{{.ResponseName}}(code int, resp {{$respType}}) error {
    return c.JSON(code, resp)
}
{{- else if (ne .ResponseName "default") }}
{{ $respName := statusText .ResponseName | camelCase | title }}
// {{$respName}} responses with the appropriate code and the JSON response.
func (c *{{$op.OperationId}}Context) {{$respName}}(resp {{$respType}}) error {
    return c.JSON({{.ResponseName}}, resp)
}
{{- end }}
{{- end }}
{{- end }}
{{ end }}

// bindValidateBody decodes and validates the body of a request. It's highly inspired 
// from the echo.DefaultBinder BindBody function.
// This is preferred over echo.Bind, since it grants more control over the binding 
// functionality. Particularly, it returns a well-formatted ValidationError on invalid input.
func bindValidateBody(c echo.Context, i validation.Validatable) error {
	req := c.Request()
	if req.ContentLength != 0 {
		// Decode
		ctype := req.Header.Get(echo.HeaderContentType)
		switch {
		case strings.HasPrefix(ctype, echo.MIMEApplicationJSON):
			if err := json.NewDecoder(req.Body).Decode(i); err != nil {
				// Add some context to the error when possible
				switch e := err.(type) {
				case *json.UnmarshalTypeError:
					err = fmt.Errorf("cannot unmarshal a value of type %v into the field %v of type %v (offset %v)", e.Value, e.Field, e.Type, e.Offset)
				case *json.SyntaxError:
					err = fmt.Errorf("%v (offset %v)", err.Error(), e.Offset)
				}
				return &ValidationError{ParamType: "body", Err: err}
			}
		default:
			return echo.ErrUnsupportedMediaType
		}
	}

	// Validate
	if err := i.Validate(); err != nil {
		return &ValidationError{ParamType: "body", Err: err}
	}
	return nil
}

// ValidationError is the special validation error type, returned from failed validation runs.
type ValidationError struct {
    ParamType string // can be "path", "cookie", "header", "query" or "body"
    Param string // which field? can be omitted, when we parse the entire struct at once
    Err error 
}

// Error implements the error interface.
func (v *ValidationError) Error() string {
    if v.Param == "" {
        return fmt.Sprintf("validation failed for '%s': %v", v.ParamType, v.Err)
    }
    return fmt.Sprintf("validation failed for %s parameter '%s': %v", v.ParamType, v.Param, v.Err)
}
